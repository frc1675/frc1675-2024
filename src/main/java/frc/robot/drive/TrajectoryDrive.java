package frc.robot.drive;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.wpilibj2.command.Command;
import frc.robot.util.AutoGenerator;

/**
 * This command calls the corresponding methods of a command generated by
 * PathPlanner. The reason that we do this instead of just scheduling the
 * generated command is because the command generator gets the robots current
 * pose to set the path starting position. If the command was bound normally,
 * the pose would always be the starting pose of the robot. This way, the
 * command is generated anew each time this command is scheduled, allowing the
 * AutoGenerator method to get the correct robot pose.
 */
public class TrajectoryDrive extends Command {

    private DriveSubsystem drive;
    private AutoGenerator generator;

    private Rotation2d endRotation;
    private Pose2d endPose;
    private Pose2d[] additionalPoses;

    private Command driveCommand;

    public TrajectoryDrive(AutoGenerator generator, DriveSubsystem drive, Rotation2d endRotation, Pose2d endPose, Pose2d...additionalPoses) {
        this.generator = generator;
        this.drive = drive;
        this.endRotation = endRotation;
        this.endPose = endPose;
        this.additionalPoses = additionalPoses;

        addRequirements(drive);
    }

    @Override
    public void initialize() {
        if (additionalPoses != null && additionalPoses.length > 0) {
            driveCommand = generator.generatePathFollowCommand(endRotation, endPose, additionalPoses);
        }else {
            driveCommand = generator.generatePathFollowCommand(endRotation, endPose);
        }
        driveCommand.initialize();
    }

    @Override
    public void execute() {
        driveCommand.execute();
    }

    @Override
    public boolean isFinished() {
        return driveCommand.isFinished();
    }

    @Override
    public void end(boolean interrupted) {
        driveCommand.end(interrupted);

        drive.drive(0, 0, 0);
    }

}
